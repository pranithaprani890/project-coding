updated approval code


import React, { useState, useEffect } from "react";
import axios from "axios";
import BackToDashboard from "../../common/components/BackToDashboard";

const BASE_URL = "http://localhost:8080/api";

export default function ApprovePayroll() {
  const [batches, setBatches] = useState([]);
  const [selected, setSelected] = useState([]);
  const [remarks, setRemarks] = useState({});
  const [showModal, setShowModal] = useState(false);
  const [actionType, setActionType] = useState(null);
  const [rejectReason, setRejectReason] = useState("");
  const [message, setMessage] = useState("");

  // ✅ Pagination states
  const [currentPage, setCurrentPage] = useState(1);
  const rowsPerPage = 6;

  useEffect(() => {
    loadBatches();
  }, []);

  const loadBatches = async () => {
    try {
      const res = await axios.get(`${BASE_URL}/payroll/batch`);
      const submitted = res.data.filter((b) => b.status === "Submitted");
      setBatches(submitted);
    } catch (err) {
      console.error(err);
      setMessage("Failed to load payroll batches.");
    }
  };

  const toggleSelect = (id) => {
    setSelected((prev) =>
      prev.includes(id) ? prev.filter((sid) => sid !== id) : [...prev, id]
    );
  };

  const confirmAction = async () => {
    try {
      await Promise.all(
        selected.map((id) =>
          axios.put(`${BASE_URL}/approval/batch/${id}`, {
            status: actionType,
            remarks: actionType === "Rejected" ? rejectReason : remarks[id] || "",
            approvedBy: "Approver User",
          })
        )
      );

      setMessage(`Batches ${actionType}!`);
      setShowModal(false);
      setSelected([]);
      setRejectReason("");
      loadBatches();
    } catch (err) {
      console.error(err);
      setMessage("Failed to update batch status.");
    }
  };

  const downloadBatch = (batch) => {
    const text = [
      `Payroll Batch — ${batch.id}`,
      `Status: ${batch.status}`,
      `Payments: ${batch.payments.length}`,
      `Total: ${getTotal(batch)} ${batch.instruction.paymentCurrency}`,
    ].join("\n");

    const blob = new Blob([text], { type: "text/plain" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = `Batch_${batch.id}.txt`;
    link.click();
  };

  const getTotal = (batch) =>
    batch.payments.reduce((sum, p) => sum + p.amount, 0);

  // ✅ Pagination logic
  const totalPages = Math.ceil(batches.length / rowsPerPage);
  const startIndex = (currentPage - 1) * rowsPerPage;
  const currentRows = batches.slice(startIndex, startIndex + rowsPerPage);

  return (
    <div className="p-6">
      <BackToDashboard />
      <h2 className="text-2xl font-bold mb-4">Approve Payroll</h2>

      {message && <p className="mb-3 text-blue-600">{message}</p>}

      <table className="w-full border border-gray-300 rounded">
        <thead>
          <tr className="bg-gray-100">
            <th className="p-2">Select</th>
            <th className="p-2">Batch ID</th>
            <th className="p-2">Payments</th>
            <th className="p-2">Total</th>
            <th className="p-2">Currency</th>
            <th className="p-2">Remarks</th>
            <th className="p-2">Download</th>
          </tr>
        </thead>
        <tbody>
          {currentRows.length > 0 ? (
            currentRows.map((b) => (
              <tr key={b.id} className="border-t">
                <td className="p-2 text-center">
                  <input
                    type="checkbox"
                    checked={selected.includes(b.id)}
                    onChange={() => toggleSelect(b.id)}
                  />
                </td>
                <td className="p-2">{b.id}</td>
                <td className="p-2">{b.payments.length}</td>
                <td className="p-2">{getTotal(b)}</td>
                <td className="p-2">{b.instruction.paymentCurrency}</td>
                <td className="p-2">
                  <input
                    type="text"
                    placeholder="Enter remarks"
                    value={remarks[b.id] || ""}
                    onChange={(e) =>
                      setRemarks({ ...remarks, [b.id]: e.target.value })
                    }
                    className="border p-1 w-full"
                  />
                </td>
                <td className="p-2">
                  <button
                    onClick={() => downloadBatch(b)}
                    className="text-blue-600 underline"
                  >
                    Download
                  </button>
                </td>
              </tr>
            ))
          ) : (
            <tr>
              <td colSpan="7" className="p-4 text-center text-gray-500">
                No payrolls to approve.
              </td>
            </tr>
          )}
        </tbody>
      </table>

      {/* ✅ Pagination Controls */}
      {batches.length > rowsPerPage && (
        <div className="flex justify-between items-center mt-4">
          <button
            onClick={() => setCurrentPage((p) => Math.max(p - 1, 1))}
            disabled={currentPage === 1}
            className="px-3 py-1 border rounded bg-gray-200 disabled:opacity-50"
          >
            Prev
          </button>
          <span>
            Page {currentPage} of {totalPages}
          </span>
          <button
            onClick={() => setCurrentPage((p) => Math.min(p + 1, totalPages))}
            disabled={currentPage === totalPages}
            className="px-3 py-1 border rounded bg-gray-200 disabled:opacity-50"
          >
            Next
          </button>
        </div>
      )}

      {batches.length > 0 && (
        <div className="mt-4 flex gap-3">
          <button
            onClick={() => {
              setActionType("Approved");
              setShowModal(true);
            }}
            className="bg-green-600 text-white px-4 py-2 rounded"
            disabled={selected.length === 0}
          >
            Approve
          </button>
          <button
            onClick={() => {
              setActionType("Rejected");
              setShowModal(true);
            }}
            className="bg-red-600 text-white px-4 py-2 rounded"
            disabled={selected.length === 0}
          >
            Reject
          </button>
        </div>
      )}

      {/* ✅ Modal */}
      {showModal && (
        <div className="fixed inset-0 bg-black bg-opacity-30 flex items-center justify-center">
          <div className="bg-white p-6 rounded-lg shadow-md w-96">
            <h3 className="text-xl font-bold mb-4">{actionType} Batches</h3>

            {actionType === "Rejected" && (
              <textarea
                value={rejectReason}
                onChange={(e) => setRejectReason(e.target.value)}
                placeholder="Enter rejection reason"
                className="border p-2 w-full mb-3"
              />
            )}

            <div className="flex justify-end gap-3">
              <button
                onClick={() => setShowModal(false)}
                className="px-4 py-2 bg-gray-300 rounded"
              >
                Cancel
              </button>
              <button
                onClick={confirmAction}
                className={`px-4 py-2 rounded text-white ${
                  actionType === "Approved" ? "bg-green-600" : "bg-red-600"
                }`}
              >
                Confirm
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}














----------------------------------------------
package paymentinitiation.approvepayroll.controller;

import paymentinitiation.approvepayroll.model.ApprovalLog;
import paymentinitiation.approvepayroll.service.ApprovalService;
import paymentinitiation.payroll.model.PayrollBatch;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/approval")
@CrossOrigin(origins = "http://localhost:3000")
public class ApprovalController {

    private final ApprovalService service;

    public ApprovalController(ApprovalService service) {
        this.service = service;
    }

    // Approve/Reject a batch
    @PutMapping("/batch/{id}")
    public PayrollBatch updateBatchStatus(@PathVariable Long id, @RequestBody Map<String, String> body) {
        String status = body.get("status");   // "Approved" or "Rejected"
        String remarks = body.getOrDefault("remarks", "");
        String approvedBy = body.getOrDefault("approvedBy", "System User");
        return service.updateStatus(id, status, remarks, approvedBy);
    }

    // View logs
    @GetMapping("/logs")
    public List<ApprovalLog> getLogs() {
        return service.getLogs();
    }
}

package paymentinitiation.approvepayroll.model;

import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "approval_logs")
public class ApprovalLog {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private Long batchId;
    private String action;        // "Approved" or "Rejected"
    private String remarks;
    private String approvedBy;
    private LocalDateTime approvedAt;

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public Long getBatchId() { return batchId; }
    public void setBatchId(Long batchId) { this.batchId = batchId; }

    public String getAction() { return action; }
    public void setAction(String action) { this.action = action; }

    public String getRemarks() { return remarks; }
    public void setRemarks(String remarks) { this.remarks = remarks; }

    public String getApprovedBy() { return approvedBy; }
    public void setApprovedBy(String approvedBy) { this.approvedBy = approvedBy; }

    public LocalDateTime getApprovedAt() { return approvedAt; }
    public void setApprovedAt(LocalDateTime approvedAt) { this.approvedAt = approvedAt; }
}



package paymentinitiation.approvepayroll.repository;

import paymentinitiation.approvepayroll.model.ApprovalLog;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface ApprovalLogRepository extends JpaRepository<ApprovalLog, Long> {
}






package paymentinitiation.approvepayroll.service;
import paymentinitiation.approvepayroll.model.ApprovalLog;
import paymentinitiation.approvepayroll.repository.ApprovalLogRepository;
import paymentinitiation.payroll.model.PayrollBatch;
import paymentinitiation.payroll.repository.PayrollBatchRepository;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

@Service
public class ApprovalService {

    private final PayrollBatchRepository batchRepo;
    private final ApprovalLogRepository logRepo;

    public ApprovalService(PayrollBatchRepository batchRepo, ApprovalLogRepository logRepo) {
        this.batchRepo = batchRepo;
        this.logRepo = logRepo;
    }

    public PayrollBatch updateStatus(Long batchId, String status, String remarks, String approver) {
        PayrollBatch batch = batchRepo.findById(batchId).orElseThrow(() -> new RuntimeException("Batch not found"));
        batch.setStatus(status);
        batch.setUpdatedAt(LocalDateTime.now().toString());
        batchRepo.save(batch);

        ApprovalLog log = new ApprovalLog();
        log.setBatchId(batchId);
        log.setAction(status);
        log.setRemarks(remarks);
        log.setApprovedBy(approver);
        log.setApprovedAt(LocalDateTime.now());
        logRepo.save(log);

        return batch;
    }

    public List<ApprovalLog> getLogs() {
        return logRepo.findAll();
    }
}







































----------------Payroll frontend

import React, { useState } from "react";
import axios from "axios";
import PrimaryButton from "../../common/components/PrimaryButton";
import { useLocation,useNavigate } from "react-router-dom";


const BASE_URL = "http://localhost:8080/api/payroll"; // Spring Boot backend URL

export default function PayrollPayment() {
  const location=useLocation();
  const navigate=useNavigate();
  const editingBatch=location.state?.batch;
  const [instruction, setInstruction] = useState(editingBatch?.instruction||{
    paymentCurrency: "",
    debitAccount: "",
    date: "",
  });

  const [payments, setPayments] = useState(editingBatch?.payments||[
    {
      payeeDetails: "",
      payeeName: "",
      accountNumber: "",
      reference: `REF-${Date.now()}`,
      amount: "",
    },
  ]);

  const handleInstructionChange = (e) => {
    const { name, value } = e.target;
    setInstruction((prev) => ({ ...prev, [name]: value }));
  };

  const handlePaymentChange = (index, e) => {
    const { name, value } = e.target;
    setPayments((prev) => {
      const updated = [...prev];
      if (name === "amount") {
        updated[index][name] = value.replace(/[^0-9]/g, "");
      } else {
        updated[index][name] = value;
      }
      return updated;
    });
  };

  const addPaymentRow = () => {
    setPayments((prev) => [
      ...prev,
      {
        payeeDetails: "",
        payeeName: "",
        accountNumber: "",
        reference: `REF-${Date.now()}`,
        amount: "",
      },
    ]);
  };

  const removePaymentRow = (index) => {
    setPayments((prev) => prev.filter((_, i) => i !== index));
  };

  const saveBatch = async (status) => {
    const batch = {
      id:editingBatch?.id|| Date.now(),
      instruction,
      payments,
      status,
      createdAt: editingBatch?.createdAt|| new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    try {
      await axios.post(`${BASE_URL}/batch`, batch);
      
      navigate("/manage-payroll"); // redirect after save
    } catch (error) {
      console.error(error);
      
    }
  };

  const totalAmount = payments.reduce(
    (sum, p) => sum + (Number(p.amount) || 0),
    0
  );

  const formatAmount = (amount) => {
    if (!instruction.paymentCurrency) return amount.toLocaleString();
    if (instruction.paymentCurrency === "INR") return `${Number(amount).toLocaleString("en-IN")} INR`;
    if (instruction.paymentCurrency === "USD") return `${Number(amount).toLocaleString("en-US")} USD`;
    return amount.toLocaleString();
  };

  const formatAmountInput = (amount) => {
    if (!amount) return "";
    if (instruction.paymentCurrency === "INR") return Number(amount).toLocaleString("en-IN");
    if (instruction.paymentCurrency === "USD") return Number(amount).toLocaleString("en-US");
    return Number(amount).toLocaleString();
  };

  return (
    <div className="container p-2">
      <div className="card p-3">
        <h2 className="text-center mb-3">Create Payroll Payments</h2>

        <form
          onSubmit={(e) => {
            e.preventDefault();
            saveBatch("Submitted");
          }}
        >
          {/* Instruction Details */}
          <h4>Instruction Details</h4>
          <div className="row mb-3">
            <div className="col">
              <label>Debit Account *</label>
              <select
                name="debitAccount"
                value={instruction.debitAccount}
                onChange={handleInstructionChange}
                className="form-select"
                required
              >
                <option value="">Select Debit Account</option>
                <option value="Corporate INR">Corporate INR</option>
                <option value="Corporate USD">Corporate USD</option>
              </select>
            </div>

            <div className="col">
              <label>Currency *</label>
              <select
                name="paymentCurrency"
                value={instruction.paymentCurrency}
                onChange={handleInstructionChange}
                className="form-select"
                required
              >
                <option value="">Select Currency</option>
                <option value="INR">INR</option>
                <option value="USD">USD</option>
              </select>
            </div>

            <div className="col">
              <label>Date *</label>
              <input
                type="date"
                name="date"
                value={instruction.date}
                onChange={handleInstructionChange}
                className="form-control"
                required
              />
            </div>
          </div>

          {/* Payment Details */}
          <h4 className="d-flex justify-content-between">
            <span>Payment Details</span>
          </h4>

          <div style={{ maxHeight: "300px", overflowY: "auto", border: "1px solid #ccc", borderRadius: "5px" }}>
            <table className="table table-bordered text-center mb-0">
              <thead className="table-light" style={{ position: "sticky", top: 0, zIndex: 1 }}>
                <tr>
                  <th>S. No.</th>
                  <th>Reference</th>
                  <th>Payee Role</th>
                  <th>Payee Name</th>
                  <th>Account Number</th>
                  <th>Amount</th>
                  <th>Action</th>
                </tr>
              </thead>
              <tbody>
                {payments.map((p, i) => (
                  <tr key={i}>
                    <td>{i + 1}</td>
                    <td><input className="form-control form-control-sm" name="reference" value={p.reference} readOnly /></td>
                    <td><input className="form-control form-control-sm" name="payeeDetails" value={p.payeeDetails} onChange={(e) => handlePaymentChange(i, e)} required /></td>
                    <td><input className="form-control form-control-sm" name="payeeName" value={p.payeeName} onChange={(e) => handlePaymentChange(i, e)} required /></td>
                    <td><input className="form-control form-control-sm" name="accountNumber" value={p.accountNumber} onChange={(e) => handlePaymentChange(i, e)} required /></td>
                    <td><input className="form-control form-control-sm text-end" type="text" name="amount" value={formatAmountInput(p.amount)} onChange={(e) => handlePaymentChange(i, e)} required /></td>
                    <td><button type="button" className="btn btn-sm btn-danger" onClick={() => removePaymentRow(i)}>Remove</button></td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>

          {/* Total Amount Sticky Bar */}
          <div style={{ position: "sticky", bottom: 0, background: "#0055a4", color: "white", borderTop: "1px solid #444", padding: "8px 12px", fontSize: "0.95rem", textAlign: "right", zIndex: 10 }}>
            <strong>Total Amount: {formatAmount(totalAmount)}</strong>
          </div>

          {/* Buttons */}
          <div className="d-flex justify-content-between align-items-center my-2">
            <button type="button" className="btn btn-outline-secondary my-2" onClick={addPaymentRow}>+ Add Payment Row</button>
            <div className="d-flex gap-2">
              <button type="button" className="btn btn-outline-secondary" onClick={() => saveBatch("Draft")}>Save as Draft</button>
              <PrimaryButton type="submit">Submit</PrimaryButton>
            </div>
          </div>
        </form>
      </div>
    </div>
  );
}
----------------------
payroll backend code

package paymentinitiation.payroll.controller;

import paymentinitiation.payroll.model.PayrollBatch;
import paymentinitiation.payroll.service.PayrollService;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/payroll")
@CrossOrigin(origins = "http://localhost:3000") // React frontend
public class PayrollController {

    private final PayrollService service;

    public PayrollController(PayrollService service) {
        this.service = service;
    }

    @PostMapping("/batch")
    public PayrollBatch saveOrSubmitBatch(@RequestBody PayrollBatch batch) {
        return service.saveBatch(batch);
    }

    @GetMapping("/batch")
    public List<PayrollBatch> getAllBatches() {
        return service.getAllBatches();
    }

    @GetMapping("/batch/{id}")
    public PayrollBatch getBatchById(@PathVariable Long id) {
        return service.getBatchById(id);
    }
}



package paymentinitiation.payroll.model;
import jakarta.persistence.Embeddable;

@Embeddable
public class Instruction {
    private String paymentCurrency;
    private String debitAccount;
    private String date;

    public String getPaymentCurrency() { return paymentCurrency; }
    public void setPaymentCurrency(String paymentCurrency) { this.paymentCurrency = paymentCurrency; }

    public String getDebitAccount() { return debitAccount; }
    public void setDebitAccount(String debitAccount) { this.debitAccount = debitAccount; }

    public String getDate() { return date; }
    public void setDate(String date) { this.date = date; }
}

package paymentinitiation.payroll.model;

import jakarta.persistence.Embeddable;

@Embeddable
public class Payment {
    private String payeeDetails;
    private String payeeName;
    private String accountNumber;
    private String reference;
    private String amount;

    public String getPayeeDetails() { return payeeDetails; }
    public void setPayeeDetails(String payeeDetails) { this.payeeDetails = payeeDetails; }

    public String getPayeeName() { return payeeName; }
    public void setPayeeName(String payeeName) { this.payeeName = payeeName; }

    public String getAccountNumber() { return accountNumber; }
    public void setAccountNumber(String accountNumber) { this.accountNumber = accountNumber; }

    public String getReference() { return reference; }
    public void setReference(String reference) { this.reference = reference; }

    public String getAmount() { return amount; }
    public void setAmount(String amount) { this.amount = amount; }
}


package paymentinitiation.payroll.model;

import jakarta.persistence.*;
import java.util.List;

@Entity
@Table(name = "payroll_batches")
public class PayrollBatch {

    @Id
    private Long id;

    @Embedded
    private Instruction instruction;

    @ElementCollection
    @CollectionTable(name = "payments", joinColumns = @JoinColumn(name = "batch_id"))
    private List<Payment> payments;

    private String status;
    private String createdAt;
    private String updatedAt;

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public Instruction getInstruction() { return instruction; }
    public void setInstruction(Instruction instruction) { this.instruction = instruction; }

    public List<Payment> getPayments() { return payments; }
    public void setPayments(List<Payment> payments) { this.payments = payments; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public String getCreatedAt() { return createdAt; }
    public void setCreatedAt(String createdAt) { this.createdAt = createdAt; }

    public String getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(String updatedAt) { this.updatedAt = updatedAt; }
}



package paymentinitiation.payroll.repository;

import paymentinitiation.payroll.model.PayrollBatch;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface PayrollBatchRepository extends JpaRepository<PayrollBatch, Long> {
}






package paymentinitiation.payroll.service;

import paymentinitiation.payroll.model.PayrollBatch;
import paymentinitiation.payroll.repository.PayrollBatchRepository;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class PayrollService {

    private final PayrollBatchRepository repository;

    public PayrollService(PayrollBatchRepository repository) {
        this.repository = repository;
    }

    public PayrollBatch saveBatch(PayrollBatch batch) {
        return repository.save(batch);
    }

    public List<PayrollBatch> getAllBatches() {
        return repository.findAll();
    }

    public PayrollBatch getBatchById(Long id) {
        return repository.findById(id).orElse(null);
    }
}















-------------------------
package com.example.approval.model;

import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "approval_logs")
public class ApprovalLog {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private Long batchId;
    private String action;        // "Approved" or "Rejected"
    private String remarks;
    private String approvedBy;
    private LocalDateTime approvedAt;

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public Long getBatchId() { return batchId; }
    public void setBatchId(Long batchId) { this.batchId = batchId; }

    public String getAction() { return action; }
    public void setAction(String action) { this.action = action; }

    public String getRemarks() { return remarks; }
    public void setRemarks(String remarks) { this.remarks = remarks; }

    public String getApprovedBy() { return approvedBy; }
    public void setApprovedBy(String approvedBy) { this.approvedBy = approvedBy; }

    public LocalDateTime getApprovedAt() { return approvedAt; }
    public void setApprovedAt(LocalDateTime approvedAt) { this.approvedAt = approvedAt; }
}
2. ApprovalLogRepository.java
java
Copy code
package com.example.approval.repo;

import com.example.approval.model.ApprovalLog;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface ApprovalLogRepository extends JpaRepository<ApprovalLog, Long> {
}
3. ApprovalService.java
java
Copy code
package com.example.approval.service;

import com.example.approval.model.ApprovalLog;
import com.example.approval.repo.ApprovalLogRepository;
import com.example.payroll.model.PayrollBatch;
import com.example.payroll.repository.PayrollBatchRepository;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

@Service
public class ApprovalService {

    private final PayrollBatchRepository batchRepo;
    private final ApprovalLogRepository logRepo;

    public ApprovalService(PayrollBatchRepository batchRepo, ApprovalLogRepository logRepo) {
        this.batchRepo = batchRepo;
        this.logRepo = logRepo;
    }

    public PayrollBatch updateStatus(Long batchId, String status, String remarks, String approver) {
        PayrollBatch batch = batchRepo.findById(batchId).orElseThrow(() -> new RuntimeException("Batch not found"));
        batch.setStatus(status);
        batch.setUpdatedAt(LocalDateTime.now().toString());
        batchRepo.save(batch);

        ApprovalLog log = new ApprovalLog();
        log.setBatchId(batchId);
        log.setAction(status);
        log.setRemarks(remarks);
        log.setApprovedBy(approver);
        log.setApprovedAt(LocalDateTime.now());
        logRepo.save(log);

        return batch;
    }

    public List<ApprovalLog> getLogs() {
        return logRepo.findAll();
    }
}
4. ApprovalController.java
java
Copy code
package com.example.approval.controller;

import com.example.approval.model.ApprovalLog;
import com.example.approval.service.ApprovalService;
import com.example.payroll.model.PayrollBatch;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/approval")
@CrossOrigin(origins = "http://localhost:3000")
public class ApprovalController {

    private final ApprovalService service;

    public ApprovalController(ApprovalService service) {
        this.service = service;
    }

    // Approve/Reject a batch
    @PutMapping("/batch/{id}")
    public PayrollBatch updateBatchStatus(@PathVariable Long id, @RequestBody Map<String, String> body) {
        String status = body.get("status");   // "Approved" or "Rejected"
        String remarks = body.getOrDefault("remarks", "");
        String approvedBy = body.getOrDefault("approvedBy", "System User");
        return service.updateStatus(id, status, remarks, approvedBy);
    }

    // View logs
    @GetMapping("/logs")
    public List<ApprovalLog> getLogs() {
        return service.getLogs();
    }
}






















-------------------
1. Add ApprovalLog.java
package com.example.approval.model;

import jakarta.persistence.*;

@Entity
@Table(name = "approval_logs")
public class ApprovalLog {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private Long batchId;
    private String status; // Approved / Rejected
    private String remarks;
    private String approvedBy;
    private String approvedAt;

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public Long getBatchId() { return batchId; }
    public void setBatchId(Long batchId) { this.batchId = batchId; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public String getRemarks() { return remarks; }
    public void setRemarks(String remarks) { this.remarks = remarks; }

    public String getApprovedBy() { return approvedBy; }
    public void setApprovedBy(String approvedBy) { this.approvedBy = approvedBy; }

    public String getApprovedAt() { return approvedAt; }
    public void setApprovedAt(String approvedAt) { this.approvedAt = approvedAt; }
}

2. Repository for logs
package com.example.approval.repo;

import com.example.approval.model.ApprovalLog;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface ApprovalLogRepository extends JpaRepository<ApprovalLog, Long> {
}

3. Service layer
package com.example.approval.service;

import com.example.approval.model.ApprovalLog;
import com.example.approval.repo.ApprovalLogRepository;
import com.example.payroll.model.PayrollBatch;
import com.example.payroll.repository.PayrollBatchRepository;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

@Service
public class ApprovalService {
    private final PayrollBatchRepository batchRepo;
    private final ApprovalLogRepository logRepo;

    public ApprovalService(PayrollBatchRepository batchRepo, ApprovalLogRepository logRepo) {
        this.batchRepo = batchRepo;
        this.logRepo = logRepo;
    }

    public PayrollBatch updateStatus(Long batchId, String status, String remarks, String approvedBy) {
        PayrollBatch batch = batchRepo.findById(batchId)
                .orElseThrow(() -> new RuntimeException("Batch not found"));

        batch.setStatus(status);
        batch.setUpdatedAt(LocalDateTime.now().toString());
        batchRepo.save(batch);

        ApprovalLog log = new ApprovalLog();
        log.setBatchId(batchId);
        log.setStatus(status);
        log.setRemarks(remarks);
        log.setApprovedBy(approvedBy);
        log.setApprovedAt(LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME));
        logRepo.save(log);

        return batch;
    }
}

4. Controller for approval
package com.example.approval.controller;

import com.example.approval.service.ApprovalService;
import com.example.payroll.model.PayrollBatch;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

@RestController
@RequestMapping("/api/approval")
@CrossOrigin(origins = "http://localhost:3000") // React frontend
public class ApprovalController {
    private final ApprovalService approvalService;

    public ApprovalController(ApprovalService approvalService) {
        this.approvalService = approvalService;
    }

    @PutMapping("/batch/{id}/status")
    public PayrollBatch updateBatchStatus(
            @PathVariable Long id,
            @RequestBody Map<String, String> request
    ) {
        String status = request.get("status");     // "Approved" / "Rejected"
        String remarks = request.get("remarks");   // optional
        String approvedBy = request.getOrDefault("approvedBy", "System User");

        return approvalService.updateStatus(id, status, remarks, approvedBy);
    }































-------------------------------
package com.example.approval.model;

import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "approval_logs")
public class ApprovalLog {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private Long batchId;
    private String status;    // Approved/Rejected
    private String remarks;
    private String approvedBy;
    private String approvedAt;

    // getters & setters omitted for brevity
}
Line-by-line / block explanation

package ... — declares package (keeps approval code separate).

@Entity — JPA will map this class to a DB table.

@Table(name = "approval_logs") — explicit table name.

@Id + @GeneratedValue(...) — primary key, auto-increment.

private Long batchId; — stores which payroll_batches.id this log belongs to.

private String status; — Approved or Rejected.

private String remarks; — approver notes or reject reason.

private String approvedBy; — who took the action.

private String approvedAt; — timestamp (stored as string for simplicity to match other models).

Provide standard getters & setters (Jackson/JPA need them).

approval/repo/ApprovalLogRepository.java
java
Copy code
package com.example.approval.repo;

import com.example.approval.model.ApprovalLog;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List;

public interface ApprovalLogRepository extends JpaRepository<ApprovalLog, Long> {
    List<ApprovalLog> findByBatchIdOrderByApprovedAtDesc(Long batchId);
}
Explanation

Extends JpaRepository giving you save(), findAll(), etc.

findByBatchIdOrderByApprovedAtDesc — convenience method to fetch history for a batch.

approval/service/ApprovalService.java
java
Copy code
package com.example.approval.service;

import com.example.approval.model.ApprovalLog;
import com.example.approval.repo.ApprovalLogRepository;
import com.example.payroll.model.PayrollBatch;
import com.example.payroll.repository.PayrollBatchRepository;
import org.springframework.stereotype.Service;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

@Service
public class ApprovalService {
    private final PayrollBatchRepository batchRepo;
    private final ApprovalLogRepository logRepo;

    public ApprovalService(PayrollBatchRepository batchRepo, ApprovalLogRepository logRepo) {
        this.batchRepo = batchRepo;
        this.logRepo = logRepo;
    }

    public PayrollBatch updateStatus(Long batchId, String status, String remarks, String approvedBy) {
        PayrollBatch batch = batchRepo.findById(batchId)
            .orElseThrow(() -> new RuntimeException("Batch not found: " + batchId));

        // update batch status & timestamp
        batch.setStatus(status);
        batch.setUpdatedAt(LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));
        batchRepo.save(batch);      // persist change to payroll_batches

        // record an approval log
        ApprovalLog log = new ApprovalLog();
        log.setBatchId(batchId);
        log.setStatus(status);
        log.setRemarks(remarks);
        log.setApprovedBy(approvedBy);
        log.setApprovedAt(LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));
        logRepo.save(log);

        return batch;
    }
}
Explanation (key lines)

Constructor injection: PayrollBatchRepository (from teammate) + ApprovalLogRepository (your repo).

batchRepo.findById(...).orElseThrow(...) — fetch batch; fail fast if not found.

batch.setStatus(status) + batch.setUpdatedAt(...) — update the existing entity.

batchRepo.save(batch) — persist status change to payroll_batches.

Build ApprovalLog, set fields, logRepo.save(log) — store history.

Return the updated PayrollBatch so controller can return it to frontend.

Why separate log? keeps approval metadata without modifying teammate’s model, and gives audit history.

approval/controller/ApprovalController.java
java
Copy code
package com.example.approval.controller;

import com.example.payroll.model.PayrollBatch;
import com.example.approval.service.ApprovalService;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/approval")
@CrossOrigin(origins = "http://localhost:3000")
public class ApprovalController {
    private final ApprovalService service;

    public ApprovalController(ApprovalService service) { this.service = service; }

    @PutMapping("/batch/{id}/status")
    public PayrollBatch updateBatchStatus(
            @PathVariable Long id,
            @RequestBody ApprovalRequestDto dto // or Map<String,String>
    ) {
        return service.updateStatus(id, dto.getStatus(), dto.getRemarks(), dto.getApprovedBy());
    }
}



-------------------------
import React, { useState } from "react";
import axios from "axios";
import PrimaryButton from "../../common/components/PrimaryButton";

export default function PayrollPayment() {
  const [instruction, setInstruction] = useState({
    paymentCurrency: "",
    debitAccount: "",
    date: "",
  });

  const [payments, setPayments] = useState([
    {
      payeeDetails: "",
      payeeName: "",
      accountNumber: "",
      reference: `REF-${Date.now()}`,
      amount: 0,
    },
  ]);

  // Handle Instruction Changes
  const handleInstructionChange = (e) => {
    const { name, value } = e.target;
    setInstruction((prev) => ({ ...prev, [name]: value }));
  };

  // Handle Payment Changes
  const handlePaymentChange = (index, e) => {
    const { name, value } = e.target;
    setPayments((prev) => {
      const updated = [...prev];
      if (name === "amount") {
        const rawValue = value.replace(/[^0-9]/g, "");
        updated[index][name] = rawValue;
      } else {
        updated[index][name] = value;
      }
      return updated;
    });
  };

  const addPaymentRow = () => {
    setPayments((prev) => [
      ...prev,
      {
        payeeDetails: "",
        payeeName: "",
        accountNumber: "",
        reference: `REF-${Date.now()}`,
        amount: 0,
      },
    ]);
  };

  const removePaymentRow = (index) => {
    setPayments((prev) => prev.filter((_, i) => i !== index));
  };

  // Save to Backend using Axios
  const saveBatch = async (status) => {
    const batchData = {
      instruction,
      payments,
      status,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    try {
      await axios.post("http://localhost:8080/api/payroll/batches", batchData);
      alert("Payroll batch saved successfully!");
      window.location.href = "/manage-payroll";
    } catch (error) {
      console.error("Error saving batch:", error);
      alert("Failed to save payroll batch. Check console.");
    }
  };

  // Total Amount
  const totalAmount = payments.reduce(
    (sum, p) => sum + (Number(p.amount) || 0),
    0
  );

  // Currency Format
  const formatAmountInput = (amount) => {
    if (!amount) return "";
    if (instruction.paymentCurrency === "INR") {
      return Number(amount).toLocaleString("en-IN");
    }
    if (instruction.paymentCurrency === "USD") {
      return Number(amount).toLocaleString("en-US");
    }
    return Number(amount).toLocaleString();
  };

  return (
    <div className="container p-1">
      <div className="card p-2">
        <h2 className="text-center mb-3">Create Payroll Payments</h2>
        <form
          onSubmit={(e) => {
            e.preventDefault();
            saveBatch("Submitted");
          }}
        >
          {/* Instruction Details */}
          <h4>Instruction Details</h4>
          <div className="row mb-3">
            <div className="col">
              <label>Debit Account *</label>
              <select
                name="debitAccount"
                value={instruction.debitAccount}
                onChange={handleInstructionChange}
                className="form-select"
                required
              >
                <option value="">Select Debit Account</option>
                <option value="Corporate INR">Corporate INR</option>
                <option value="Corporate USD">Corporate USD</option>
              </select>
            </div>
            <div className="col">
              <label>Currency *</label>
              <select
                name="paymentCurrency"
                value={instruction.paymentCurrency}
                onChange={handleInstructionChange}
                className="form-select"
                required
              >
                <option value="">Select Currency</option>
                <option value="INR"> INR</option>
                <option value="USD"> USD</option>
              </select>
            </div>
            <div className="col">
              <label>Date *</label>
              <input
                type="date"
                name="date"
                value={instruction.date}
                onChange={handleInstructionChange}
                className="form-control"
                required
              />
            </div>
          </div>

          {/* Payments Table */}
          <h4 className="d-flex justify-content-between">
            <span>Payment Details</span>
          </h4>
          <div
            style={{
              maxHeight: "300px",
              overflowY: "auto",
              border: "1px solid #ccc",
              borderRadius: "5px",
            }}
          >
            <table className="table table-bordered text-center mb-0">
              <thead
                className="table-light"
                style={{ position: "sticky", top: 0, zIndex: 10 }}
              >
                <tr>
                  <th>S. No.</th>
                  <th>Reference</th>
                  <th>Payee Role *</th>
                  <th>Payee Name *</th>
                  <th>Account Number *</th>
                  <th>Amount *</th>
                  <th>Action </th>
                </tr>
              </thead>
              <tbody>
                {payments.map((p, i) => (
                  <tr key={i}>
                    <td>{i + 1}</td>
                    <td>
                      <input
                        className="form-control form-control-sm"
                        name="reference"
                        value={p.reference}
                        readOnly
                      />
                    </td>
                    <td>
                      <input
                        className="form-control form-control-sm"
                        name="payeeDetails"
                        value={p.payeeDetails}
                        onChange={(e) => handlePaymentChange(i, e)}
                        required
                      />
                    </td>
                    <td>
                      <input
                        className="form-control form-control-sm"
                        name="payeeName"
                        value={p.payeeName}
                        onChange={(e) => handlePaymentChange(i, e)}
                        required
                      />
                    </td>
                    <td>
                      <input
                        className="form-control form-control-sm"
                        name="accountNumber"
                        value={p.accountNumber}
                        onChange={(e) => handlePaymentChange(i, e)}
                        required
                      />
                    </td>
                    <td>
                      <input
                        className="form-control form-control-sm text-end"
                        type="text"
                        name="amount"
                        value={formatAmountInput(p.amount)}
                        onChange={(e) => handlePaymentChange(i, e)}
                        required
                      />
                    </td>
                    <td>
                      <button
                        type="button"
                        className="btn btn-sm btn-danger"
                        onClick={() => removePaymentRow(i)}
                      >
                        Remove
                      </button>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>

          {/* Footer */}
          <div
            style={{
              position: "sticky",
              bottom: 0,
              background: "#0055a4",
              color: "white",
              borderTop: "1px solid #444",
              padding: "8px 12px",
              fontSize: "0.95rem",
              textAlign: "right",
              zIndex: 10,
            }}
          >
            <strong>Total Amount: {formatAmountInput(totalAmount)}</strong>
          </div>

          <div className="d-flex justify-content-between align-items-center my-2">
            <button
              type="button"
              className="btn btn-outline-secondary my-2"
              onClick={addPaymentRow}
            >
              + Add Payment Row
            </button>
            <div className="d-flex gap-2 ">
              <button
                type="button"
                className="btn btn-outline-secondary"
                onClick={() => saveBatch("Draft")}
              >
                Save as Draft
              </button>
              <PrimaryButton type="submit">Submit</PrimaryButton>
            </div>
          </div>
        </form>
      </div>
    </div>
  );
}













-------import React, { useState } from "react";
import axios from "axios";

export default function PayrollPayment() {
  const [instruction, setInstruction] = useState({
    paymentCurrency: "",
    debitAccount: "",
    date: "",
  });
  const [payments, setPayments] = useState([
    { employeeId: "", employeeName: "", netPay: "" },
  ]);

  // Handle instruction change
  const handleInstructionChange = (e) => {
    setInstruction({ ...instruction, [e.target.name]: e.target.value });
  };

  // Handle payment change
  const handlePaymentChange = (index, e) => {
    const updatedPayments = [...payments];
    updatedPayments[index][e.target.name] = e.target.value;
    setPayments(updatedPayments);
  };

  // Add a new payment row
  const addPaymentRow = () => {
    setPayments([
      ...payments,
      { employeeId: "", employeeName: "", netPay: "" },
    ]);
  };

  // Save batch (to backend instead of localStorage)
  const saveBatch = async (status) => {
    const batch = {
      id: Date.now(), // simple unique ID
      instruction,
      payments,
      status,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    try {
      await axios.post("http://localhost:8080/api/payroll/batch", batch);
      alert("Payroll batch saved successfully!");
      window.location.href = "/manage-payroll"; // redirect after saving
    } catch (error) {
      console.error("Error saving payroll batch:", error);
      alert("Failed to save payroll batch!");
    }
  };

  return (
    <div>
      <h2>Create Payroll Batch</h2>

      {/* Instruction Section */}
      <h3>Instruction</h3>
      <input
        type="text"
        name="paymentCurrency"
        placeholder="Payment Currency"
        value={instruction.paymentCurrency}
        onChange={handleInstructionChange}
      />
      <input
        type="text"
        name="debitAccount"
        placeholder="Debit Account"
        value={instruction.debitAccount}
        onChange={handleInstructionChange}
      />
      <input
        type="date"
        name="date"
        value={instruction.date}
        onChange={handleInstructionChange}
      />

      {/* Payments Section */}
      <h3>Payments</h3>
      {payments.map((payment, index) => (
        <div key={index}>
          <input
            type="text"
            name="employeeId"
            placeholder="Employee ID"
            value={payment.employeeId}
            onChange={(e) => handlePaymentChange(index, e)}
          />
          <input
            type="text"
            name="employeeName"
            placeholder="Employee Name"
            value={payment.employeeName}
            onChange={(e) => handlePaymentChange(index, e)}
          />
          <input
            type="number"
            name="netPay"
            placeholder="Net Pay"
            value={payment.netPay}
            onChange={(e) => handlePaymentChange(index, e)}
          />
        </div>
      ))}
      <button onClick={addPaymentRow}>+ Add Payment</button>

      {/* Action Buttons */}
      <br />
      <button onClick={() => saveBatch("Draft")}>Save as Draft</button>
      <button onClick={() => saveBatch("Submitted")}>Submit</button>
    </div>
  );
}




















package com.example.payroll.model;

import jakarta.persistence.Embeddable;

@Embeddable
public class Instruction {
    private String paymentCurrency;
    private String debitAccount;
    private String date;

    public String getPaymentCurrency() { return paymentCurrency; }
    public void setPaymentCurrency(String paymentCurrency) { this.paymentCurrency = paymentCurrency; }

    public String getDebitAccount() { return debitAccount; }
    public void setDebitAccount(String debitAccount) { this.debitAccount = debitAccount; }

    public String getDate() { return date; }
    public void setDate(String date) { this.date = date; }
}
package com.example.payroll.model;

import jakarta.persistence.Embeddable;

@Embeddable
public class Payment {
    private String payeeDetails;
    private String payeeName;
    private String accountNumber;
    private String reference;
    private String amount;

    public String getPayeeDetails() { return payeeDetails; }
    public void setPayeeDetails(String payeeDetails) { this.payeeDetails = payeeDetails; }

    public String getPayeeName() { return payeeName; }
    public void setPayeeName(String payeeName) { this.payeeName = payeeName; }

    public String getAccountNumber() { return accountNumber; }
    public void setAccountNumber(String accountNumber) { this.accountNumber = accountNumber; }

    public String getReference() { return reference; }
    public void setReference(String reference) { this.reference = reference; }

    public String getAmount() { return amount; }
    public void setAmount(String amount) { this.amount = amount; }
}
package com.example.payroll.model;

import jakarta.persistence.*;
import java.util.List;

@Entity
@Table(name = "payroll_batches")
public class PayrollBatch {

    @Id
    private Long id;

    @Embedded
    private Instruction instruction;

    @ElementCollection
    @CollectionTable(name = "payments", joinColumns = @JoinColumn(name = "batch_id"))
    private List<Payment> payments;

    private String status;
    private String createdAt;
    private String updatedAt;

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public Instruction getInstruction() { return instruction; }
    public void setInstruction(Instruction instruction) { this.instruction = instruction; }

    public List<Payment> getPayments() { return payments; }
    public void setPayments(List<Payment> payments) { this.payments = payments; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public String getCreatedAt() { return createdAt; }
    public void setCreatedAt(String createdAt) { this.createdAt = createdAt; }

    public String getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(String updatedAt) { this.updatedAt = updatedAt; }
}
package com.example.payroll.repository;

import com.example.payroll.model.PayrollBatch;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface PayrollBatchRepository extends JpaRepository<PayrollBatch, Long> {
}
package com.example.payroll.service;

import com.example.payroll.model.PayrollBatch;
import com.example.payroll.repository.PayrollBatchRepository;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class PayrollService {

    private final PayrollBatchRepository repository;

    public PayrollService(PayrollBatchRepository repository) {
        this.repository = repository;
    }

    public PayrollBatch saveBatch(PayrollBatch batch) {
        return repository.save(batch);
    }

    public List<PayrollBatch> getAllBatches() {
        return repository.findAll();
    }

    public PayrollBatch getBatchById(Long id) {
        return repository.findById(id).orElse(null);
    }
}
package com.example.payroll.controller;

import com.example.payroll.model.PayrollBatch;
import com.example.payroll.service.PayrollService;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/payroll")
@CrossOrigin(origins = "http://localhost:3000") // React frontend
public class PayrollController {

    private final PayrollService service;

    public PayrollController(PayrollService service) {
        this.service = service;
    }

    @PostMapping("/batch")
    public PayrollBatch saveOrSubmitBatch(@RequestBody PayrollBatch batch) {
        return service.saveBatch(batch);
    }

    @GetMapping("/batch")
    public List<PayrollBatch> getAllBatches() {
        return service.getAllBatches();
    }

    @GetMapping("/batch/{id}")
    public PayrollBatch getBatchById(@PathVariable Long id) {
        return service.getBatchById(id);
    }
}
	










at org.postgresql.jdbc.PgStatement.execute(PgStatement.java:415) ~[postgresql-42.6.2.jar:42.6.2]
	at org.postgresql.jdbc.PgStatement.executeWithFlags(PgStatement.java:335) ~[postgresql-42.6.2.jar:42.6.2]
	at org.postgresql.jdbc.PgStatement.executeCachedSql(PgStatement.java:321) ~[postgresql-42.6.2.jar:42.6.2]
	at org.postgresql.jdbc.PgStatement.executeWithFlags(PgStatement.java:297) ~[postgresql-42.6.2.jar:42.6.2]
	at org.postgresql.jdbc.PgStatement.execute(PgStatement.java:292) ~[postgresql-42.6.2.jar:42.6.2]
	at com.zaxxer.hikari.pool.ProxyStatement.execute(ProxyStatement.java:94) ~[HikariCP-5.0.1.jar:na]
	at com.zaxxer.hikari.pool.HikariProxyStatement.execute(HikariProxyStatement.java) ~[HikariCP-5.0.1.jar:na]
	at org.springframework.jdbc.datasource.init.ScriptUtils.executeSqlScript(ScriptUtils.java:261) ~[spring-jdbc-6.1.6.jar:6.1.6]
	... 28 common frames omitted


Process finished with exit code 1









spring.datasource.url=jdbc:postgresql://localhost:5412/postgres
spring.datasource.driverClassName=org.postgresql.Driver
spring.datasource.username=postgres
spring.datasource.password=

spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect


spring.sql.init.mode=never
spring.jpa.hibernate.ddl-auto=update

{
    "timestamp": "2025-08-24T13:32:57.754+00:00",
    "status": 404,
    "error": "Not Found",
    "path": "/api/locations/city/Bangalore"
}









1. DemoApplication.java
package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}

2. NumberController.java
package com.example.demo.controller;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/numbers")
public class NumberController {

    @GetMapping("/{num}")
    public ResponseEntity<String> checkMultipleOfFive(@PathVariable int num) {
        if (num % 5 == 0) {
            return ResponseEntity
                    .status(HttpStatus.OK)
                    .body("Yes, " + num + " is a multiple of 5");
        } else {
            return ResponseEntity
                    .status(HttpStatus.BAD_REQUEST)
                    .body("No, " + num + " is not a multiple of 5");
        }
    }
}


✅ Run this with mvn spring-boot:run → server will start on http://localhost:8080.

🟡 React Frontend

Let’s make a simple component that lets the user enter a number, calls the API, and displays the result.

CheckNumber.js
import React, { useState } from "react";

export default function CheckNumber() {
  const [num, setNum] = useState("");
  const [message, setMessage] = useState("");
  const [status, setStatus] = useState(null);

  const checkNumber = async () => {
    if (!num) return;
    try {
      const response = await fetch(`http://localhost:8080/api/numbers/${num}`);
      const text = await response.text();
      setMessage(text);
      setStatus(response.status);
    } catch (err) {
      setMessage("Error connecting to server");
      setStatus(null);
    }
  };

  return (
    <div style={{ padding: "20px", fontFamily: "Arial" }}>
      <h2>Check Multiple of 5</h2>
      <input
        type="number"
        value={num}
        onChange={(e) => setNum(e.target.value)}
        placeholder="Enter a number"
      />
      <button onClick={checkNumber} style={{ marginLeft: "10px" }}>
        Check
      </button>
      {message && (
        <p style={{ marginTop: "15px", color: status === 200 ? "green" : "red" }}>
          {message} (HTTP {status})
        </p>
      )}
    </div>
  );
}

Usage in React App

In your App.js:

import React from "react";
import CheckNumber from "./CheckNumber";

function App() {
  return (
    <div>
      <CheckNumber />
    </div>
  );
}


export default App;


















// src/services/numberService.js

const API_URL = "http://localhost:8080/api/numbers";

export async function checkMultipleOfFive(num) {
  try {
    const response = await fetch(`${API_URL}/${num}`);
    const text = await response.text();
    return {
      status: response.status,
      message: text
    };
  } catch (error) {
    return {
      status: null,
      message: "Error connecting to server"
    };
  }
}





// src/CheckNumber.js
import React, { useState } from "react";
import { checkMultipleOfFive } from "./services/numberService";

export default function CheckNumber() {
  const [num, setNum] = useState("");
  const [result, setResult] = useState(null);

  const handleCheck = async () => {
    if (!num) return;
    const res = await checkMultipleOfFive(num);
    setResult(res);
  };

  return (
    <div style={{ padding: "20px", fontFamily: "Arial" }}>
      <h2>Check Multiple of 5</h2>
      <input
        type="number"
        value={num}
        onChange={(e) => setNum(e.target.value)}
        placeholder="Enter a number"
      />
      <button onClick={handleCheck} style={{ marginLeft: "10px" }}>
        Check
      </button>

      {result && (
        <p
          style={{
            marginTop: "15px",
            color: result.status === 200 ? "green" : "red"
          }}
        >
          {result.message} (HTTP {result.status})
        </p>
      )}
    </div>
  );
}




import React from "react";
import CheckNumber from "./CheckNumber";

function App() {
  return <CheckNumber />;
}

export default App;





























1. application.properties
spring.datasource.url=jdbc:postgresql://localhost:5432/locationsdb
spring.datasource.username=postgres
spring.datasource.password=yourpassword
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

2. Location.java
package com.example.demo.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;

@Entity
@Table(name = "locations")
public class Location {

    @Id
    private Long pincode;   // Primary key
    private String city;
    private String area;

    public Location() {}

    public Location(Long pincode, String city, String area) {
        this.pincode = pincode;
        this.city = city;
        this.area = area;
    }

    public Long getPincode() { return pincode; }
    public void setPincode(Long pincode) { this.pincode = pincode; }

    public String getCity() { return city; }
    public void setCity(String city) { this.city = city; }

    public String getArea() { return area; }
    public void setArea(String area) { this.area = area; }
}

3. LocationRepository.java
package com.example.demo.repository;

import com.example.demo.entity.Location;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface LocationRepository extends JpaRepository<Location, Long> {
    List<Location> findByCityIgnoreCase(String city);
}

4. LocationService.java
package com.example.demo.service;

import com.example.demo.entity.Location;
import com.example.demo.repository.LocationRepository;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;

@Service
public class LocationService {

    private final LocationRepository repo;

    public LocationService(LocationRepository repo) {
        this.repo = repo;
    }

    public Optional<Location> getLocationByPincode(Long pincode) {
        return repo.findById(pincode);
    }

    public List<Location> getPincodesByCity(String city) {
        return repo.findByCityIgnoreCase(city);
    }
}

5. LocationController.java
package com.example.demo.controller;

import com.example.demo.entity.Location;
import com.example.demo.service.LocationService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/locations")
@CrossOrigin(origins = "http://localhost:3000")
public class LocationController {

    private final LocationService service;

    public LocationController(LocationService service) {
        this.service = service;
    }

    // Get info about city, area, pincode by specifying pincode
    @GetMapping("/pincode/{pincode}")
    public ResponseEntity<?> getLocationByPincode(@PathVariable Long pincode) {
        return service.getLocationByPincode(pincode)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    // Get all pincodes associated with a city
    @GetMapping("/city/{city}")
    public ResponseEntity<List<Location>> getPincodesByCity(@PathVariable String city) {
        return ResponseEntity.ok(service.getPincodesByCity(city));
    }
}

🟡 React Frontend
Project Structure
react-location/
 └── src/
     ├── services/locationService.js
     ├── LocationSearch.js
     ├── App.js
     └── index.js

1. locationService.js
const API_URL = "http://localhost:8080/api/locations";

export async function getLocationByPincode(pincode) {
  const res = await fetch(`${API_URL}/pincode/${pincode}`);
  if (!res.ok) throw new Error("Pincode not found");
  return res.json();
}

export async function getPincodesByCity(city) {
  const res = await fetch(`${API_URL}/city/${city}`);
  if (!res.ok) throw new Error("City not found");
  return res.json();
}

2. LocationSearch.js
import React, { useState } from "react";
import { getLocationByPincode, getPincodesByCity } from "./services/locationService";

export default function LocationSearch() {
  const [pincode, setPincode] = useState("");
  const [city, setCity] = useState("");
  const [result, setResult] = useState(null);
  const [error, setError] = useState("");

  const searchByPincode = async () => {
    try {
      const data = await getLocationByPincode(pincode);
      setResult(data);
      setError("");
    } catch (err) {
      setError(err.message);
      setResult(null);
    }
  };

  const searchByCity = async () => {
    try {
      const data = await getPincodesByCity(city);
      setResult(data);
      setError("");
    } catch (err) {
      setError(err.message);
      setResult(null);
    }
  };

  return (
    <div style={{ padding: "20px", fontFamily: "Arial" }}>
      <h2>Location Search</h2>

      <div>
        <input
          type="number"
          placeholder="Enter Pincode"
          value={pincode}
          onChange={(e) => setPincode(e.target.value)}
        />
        <button onClick={searchByPincode}>Search by Pincode</button>
      </div>

      <div style={{ marginTop: "15px" }}>
        <input
          type="text"
          placeholder="Enter City"
          value={city}
          onChange={(e) => setCity(e.target.value)}
        />
        <button onClick={searchByCity}>Search by City</button>
      </div>

      {error && <p style={{ color: "red" }}>{error}</p>}

      {result && (
        <pre style={{ marginTop: "20px", background: "#f4f4f4", padding: "10px" }}>
          {JSON.stringify(result, null, 2)}
        </pre>
      )}
    </div>
  );
}

3. App.js
import React from "react";
import LocationSearch from "./LocationSearch";

function App() {
  return (
    <div>
      <LocationSearch />
    </div>
  );
}

export default App;






// src/services/numberService.js
import axios from "axios";

const API_URL = "http://localhost:8080/api/numbers";

export async function checkMultipleOfFive(num) {
  try {
    const response = await axios.get(`${API_URL}/${num}`, {
      responseType: "text", // ensures backend text response is handled correctly
    });

    return {
      status: response.status,
      message: response.data,
    };
  } catch (error) {
    return {
      status: error.response ? error.response.status : null,
      message: error.response ? error.response.data : "Error connecting to server",
    };
  }
}

CREATE TABLE locations (
    pincode BIGINT PRIMARY KEY,
    city VARCHAR(100) NOT NULL,
    area VARCHAR(100) NOT NULL
);





















react router:



App.js
import React, { useState } from "react";
import { Routes, Route } from "react-router-dom";
import Navbar from "./components/Navbar";
import Home from "./components/Home";
import About from "./components/About";
import CustomerList from "./components/CustomerList";
import CustomerForm from "./components/CustomerForm";
import CustomerDetails from "./components/CustomerDetails";
import { initialCustomers } from "./data/mockData";

export default function App() {
  const [customers, setCustomers] = useState(initialCustomers);

  const addCustomer = (customer) => {
    setCustomers([...customers, { ...customer, id: Date.now() }]);
  };

  const updateCustomer = (updatedCustomer) => {
    setCustomers(
      customers.map((c) => (c.id === updatedCustomer.id ? updatedCustomer : c))
    );
  };

  const deleteCustomer = (id) => {
    if (window.confirm("Are you sure you want to delete this customer?")) {
      setCustomers(customers.filter((c) => c.id !== id));
    }
  };

  return (
    <div>
      <Navbar />
      <div className="container">
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
          <Route
            path="/customers"
            element={<CustomerList customers={customers} onDelete={deleteCustomer} />}
          />
          <Route
            path="/customers/new"
            element={<CustomerForm onSave={addCustomer} />}
          />
          <Route
            path="/customers/edit/:id"
            element={<CustomerForm customers={customers} onSave={updateCustomer} />}
          />
          <Route
            path="/customers/:id"
            element={<CustomerDetails customers={customers} />}
          />
        </Routes>
      </div>
    </div>
  );
}

components/Navbar.js
import React from "react";
import { Link } from "react-router-dom";

export default function Navbar() {
  return (
    <nav className="navbar">
      <div className="navbar-brand">TopGuns Bank</div>
      <ul className="nav-links">
        <li><Link to="/">Home</Link></li>
        <li><Link to="/customers">Customers</Link></li>
        <li><Link to="/about">About</Link></li>
        <li><Link to="/">SCB</Link></li>
      </ul>
    </nav>
  );
}

components/Home.js
import React from "react";

export default function Home() {
  return (
    <div>
      <h2>Welcome to TopGuns Bank</h2>
      <p>This app helps admins manage customers and their account details.</p>
    </div>
  );
}

components/About.js
import React from "react";

export default function About() {
  return (
    <div>
      <h2>About TopGuns Bank</h2>
      <p>
        TopGuns Bank is committed to providing financial services to all.
        This app helps the bank manage customer data and accounts efficiently.
      </p>
    </div>
  );
}

components/CustomerList.js
import React from "react";
import { Link } from "react-router-dom";

export default function CustomerList({ customers, onDelete }) {
  return (
    <div>
      <h2>Customers List</h2>
      <Link to="/customers/new" className="btn">Create new customer</Link>
      <table>
        <thead>
          <tr>
            <th>Id</th><th>First Name</th><th>Last Name</th>
            <th>Email</th><th>Actions</th>
          </tr>
        </thead>
        <tbody>
          {customers.map((c) => (
            <tr key={c.id}>
              <td>{c.id}</td>
              <td>{c.firstName}</td>
              <td>{c.lastName}</td>
              <td>{c.email}</td>
              <td>
                <Link to={`/customers/${c.id}`}>Show</Link> |{" "}
                <Link to={`/customers/edit/${c.id}`}>Edit</Link> |{" "}
                <button onClick={() => onDelete(c.id)} className="link-btn">Delete</button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

components/CustomerForm.js
import React, { useState, useEffect } from "react";
import { useNavigate, useParams } from "react-router-dom";

export default function CustomerForm({ customers = [], onSave }) {
  const { id } = useParams();
  const navigate = useNavigate();

  const existingCustomer = customers.find((c) => c.id === parseInt(id));
  const [form, setForm] = useState(
    existingCustomer || { firstName: "", lastName: "", email: "", phone: "" }
  );

  useEffect(() => {
    if (existingCustomer) setForm(existingCustomer);
  }, [existingCustomer]);

  const handleChange = (e) => {
    setForm({ ...form, [e.target.name]: e.target.value });
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    if (!form.firstName || !form.lastName || !form.email) {
      alert("Please fill all required fields!");
      return;
    }
    if (id) {
      onSave({ ...form, id: parseInt(id) });
    } else {
      onSave(form);
    }
    navigate("/customers");
  };

  return (
    <div>
      <h2>{id ? "Edit Customer" : "Add Customer"}</h2>
      <form onSubmit={handleSubmit}>
        <input name="firstName" placeholder="First Name" value={form.firstName} onChange={handleChange} />
        <input name="lastName" placeholder="Last Name" value={form.lastName} onChange={handleChange} />
        <input name="email" placeholder="Email" value={form.email} onChange={handleChange} />
        <input name="phone" placeholder="Phone" value={form.phone} onChange={handleChange} />
        <button type="submit" className="btn">{id ? "Update" : "Create"} Customer</button>
      </form>
      <button className="btn" onClick={() => navigate("/customers")}>Back to List</button>
    </div>
  );
}

components/CustomerDetails.js
import React from "react";
import { useParams, useNavigate } from "react-router-dom";

export default function CustomerDetails({ customers }) {
  const { id } = useParams();
  const navigate = useNavigate();

  const customer = customers.find((c) => c.id === parseInt(id));

  if (!customer) return <p>Customer not found</p>;

  return (
    <div>
      <button className="btn" onClick={() => navigate("/customers")}>
        &lt; Back to Customers List
      </button>
      <h2>Customer Details</h2>
      <p><strong>ID:</strong> {customer.id}</p>
      <p><strong>First Name:</strong> {customer.firstName}</p>
      <p><strong>Last Name:</strong> {customer.lastName}</p>
      <p><strong>Email:</strong> {customer.email}</p>
      <p><strong>Phone:</strong> {customer.phone}</p>

      <h3>List of Accounts</h3>
      <table>
        <thead>
          <tr><th>Account No</th><th>Type</th><th>Branch</th><th>Balance</th></tr>
        </thead>
        <tbody>
          {customer.accounts?.map((acc, i) => (
            <tr key={i}>
              <td>{acc.no}</td>
              <td>{acc.type}</td>
              <td>{acc.branch}</td>
              <td>{acc.balance}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

data/mockData.js
export const initialCustomers = [
  {
    id: 1,
    firstName: "Sundar",
    lastName: "Pichai",
    email: "sundar.pichai@google.com",
    phone: "",
    accounts: [
      { no: "1001999", type: "SAVINGS_ACCOUNT", branch: "Bellandur", balance: 1000 },
      { no: "1001888", type: "SAVINGS_ACCOUNT", branch: "Indira Nagar", balance: 2000 },
    ],
  },
  {
    id: 2,
    firstName: "Jeff",
    lastName: "Bezos",
    email: "jeff.bezos@amazon.com",
    phone: "",
    accounts: [{ no: "1002000", type: "CURRENT_ACCOUNT", branch: "Whitefield", balance: 5000 }],
  },
];

App.css
body {
  font-family: Arial, sans-serif;
  margin: 0;
  background: #f9f9f9;
}

.container {
  padding: 20px;
}

.navbar {
  background: #222;
  color: white;
  padding: 10px 20px;
  display: flex;
  justify-content: space-between;
}

.nav-links {
  list-style: none;
  display: flex;
  gap: 15px;
}

.nav-links li a {
  color: white;
  text-decoration: none;
}

table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 15px;
  background: white;
}

th, td {
  border: 1px solid #ddd;
  padding: 10px;
}

th {
  background: #eee;
}

.btn {
  padding: 6px 12px;
  margin: 5px;
  background: #007bff;
  border: none;
  color: white;
  cursor: pointer;
}

.btn:hover {
  background: #0056b3;
}

.link-btn {
  background: none;
  border: none;
  color: blue;
  cursor: pointer;
  text-decoration: underline;
}

import React from "react";
import ReactDOM from "react-dom/client";
import { BrowserRouter } from "react-router-dom";
import App from "./App";
import "./App.css";

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  <BrowserRouter>
    <App />
  </BrowserRouter>
);





INSERT INTO locations (pincode, city, area) VALUES
(560001, 'Bangalore', 'MG Road'),
(560037, 'Bangalore', 'Marathahalli'),
(500081, 'Hyderabad', 'HITEC City'),
(500072, 'Hyderabad', 'Kukatpally'),
(110001, 'New Delhi', 'Connaught Place'),
(400001, 'Mumbai', 'Fort'),
(400050, 'Mumbai', 'Bandra'),
(600028, 'Chennai', 'Mylapore'),
(600100, 'Chennai', 'Velachery');





spring.jpa.hibernate.ddl-auto=none
spring.jpa.show-sql=true

spring.sql.init.mode=always
spring.datasource.initialization-mode=always



























package task2.controller;

import task2.entity.Location;
import task2.service.LocationService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/locations")
@CrossOrigin(origins = "http://localhost:3000")
public class LocationController {

    private final LocationService service;

    public LocationController(LocationService service) {
        this.service = service;
    }

    // Get info about city, area, pincode by specifying pincode
    @GetMapping("/pincode/{pincode}")
    public ResponseEntity<?> getLocationByPincode(@PathVariable Long pincode) {
        return service.getLocationByPincode(pincode)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    // Get all pincodes associated with a city
    @GetMapping("/city/{city}")
    public ResponseEntity<List<Location>> getPincodesByCity(@PathVariable String city) {
        return ResponseEntity.ok(service.getPincodesByCity(city));
    }
}

package task2.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;

@Entity
@Table(name = "locations")
public class Location {

    @Id
    private Long pincode;   // Primary key
    private String city;
    private String area;

    public Location() {}

    public Location(Long pincode, String city, String area) {
        this.pincode = pincode;
        this.city = city;
        this.area = area;
    }

    public Long getPincode() { return pincode; }
    public void setPincode(Long pincode) { this.pincode = pincode; }

    public String getCity() { return city; }
    public void setCity(String city) { this.city = city; }

    public String getArea() { return area; }
    public void setArea(String area) { this.area = area; }
}



package task2.repository;

import task2.entity.Location;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface LocationRepository extends JpaRepository<Location, Long> {
    List<Location> findByCityIgnoreCase(String city);
}


package task2.service;

import task2.entity.Location;
import task2.repository.LocationRepository;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;

@Service
public class LocationService {

    private final LocationRepository repo;

    public LocationService(LocationRepository repo) {
        this.repo = repo;
    }

    public Optional<Location> getLocationByPincode(Long pincode) {
        return repo.findById(pincode);
    }

    public List<Location> getPincodesByCity(String city) {
        return repo.findByCityIgnoreCase(city);
    }
}

package task2;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(task.DemoApplication.class, args);
    }
}

INSERT INTO locations (pincode, city, area) VALUES
(560001, 'Bangalore', 'MG Road'),
(560037, 'Bangalore', 'Marathahalli'),
(500081, 'Hyderabad', 'HITEC City'),
(500072, 'Hyderabad', 'Kukatpally'),
(110001, 'New Delhi', 'Connaught Place'),
(400001, 'Mumbai', 'Fort'),
(400050, 'Mumbai', 'Bandra'),
(600028, 'Chennai', 'Mylapore'),
(600100, 'Chennai', 'Velachery');




CREATE TABLE IF NOT EXISTS locations (
    pincode BIGINT PRIMARY KEY,
    city VARCHAR(100) NOT NULL,
    area VARCHAR(100) NOT NULL
);

spring.datasource.url=jdbc:postgresql://localhost:5412/postgres
spring.datasource.driverClassName=org.postgresql.Driver
spring.datasource.username=postgres
spring.datasource.password=

spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect


spring.sql.init.mode=never
spring.jpa.hibernate.ddl-auto=update


C:\Users\2031168\goldenversions\postgresql-13.3-2-windows-x64-binaries\pgsql>pg_ctl start
pg_ctl: another server might be running; trying to start server anyway
waiting for server to start....2025-08-24 18:21:36.423 IST [20840] LOG:  starting PostgreSQL 13.3, compiled by Visual C++ build 1914, 64-bit
2025-08-24 18:21:36.427 IST [20840] LOG:  listening on IPv6 address "::1", port 5412
2025-08-24 18:21:36.428 IST [20840] LOG:  listening on IPv4 address "127.0.0.1", port 5412
2025-08-24 18:21:36.479 IST [15760] LOG:  database system was interrupted; last known up at 2025-08-22 17:46:05 IST
2025-08-24 18:21:37.317 IST [15760] LOG:  database system was not properly shut down; automatic recovery in progress
2025-08-24 18:21:37.321 IST [15760] LOG:  invalid record length at 0/164D2D8: wanted 24, got 0
2025-08-24 18:21:37.322 IST [15760] LOG:  redo is not required
2025-08-24 18:21:37.400 IST [20840] LOG:  database system is ready to accept connections


{
    "timestamp": "2025-08-24T13:41:49.633+00:00",
    "status": 404,
    "error": "Not Found",
    "path": "/api/locations/city/Bangalore"
}
















import React, { useState } from 'react';
import { approvals } from '../../common/mockData';
import DataTable from '../../common/components/DataTable';
import ConfirmModal from '../../common/components/ConfirmModal';
import BackToDashboard from '../../common/components/BackToDashboard'

export default function Approval() {
  const [list, setList] = useState(approvals);

  const act = (id, action) => {
    setList(l => l.filter(x => x.id !== id));
    alert(`${action} ${id} (mock)`);
  };

  const columns = [
    { key:'id', header:'ID' },
    { key:'date', header:'Date' },
    { key:'employeeId', header:'Employee' },
    { key:'currency', header:'CCY' },
    { key:'amount', header:'Amount' }
  ];

  return (
    <div className="d-grid gap-3">
      <h2 className="h5">Pending Approvals</h2>
      <DataTable
        columns={columns}
        rows={list}
        actions={(r)=>(
          <>
            <button
              className="btn btn-sm btn-outline-success me-2"
              data-bs-toggle="modal"
              data-bs-target="#approve"
              onClick={()=>window.__approve_id=r.id}
            >Approve</button>
            <button
              className="btn btn-sm btn-outline-danger"
              data-bs-toggle="modal"
              data-bs-target="#reject"
              onClick={()=>window.__reject_id=r.id}
            >Reject</button>
          </>
        )}
      />
      <ConfirmModal id="approve" title="Approve payment"
        body="Are you sure you want to approve?"
        onConfirm={()=>act(window.__approve_id,'Approved')} />
      <ConfirmModal id="reject" title="Reject payment"
        body="Are you sure you want to reject?"
        onConfirm={()=>act(window.__reject_id,'Rejected')} />
        <BackToDashboard />
    </div>
  );
}













import React, { useState, useEffect } from "react";
import BackToDashboard from "../../common/components/BackToDashboard";
import { getAllBatches, setStatus, downloadText } from "../../common/storage/payrollStore";
import { openPrintWindow } from "../../common/utils/pdf";
import { deductFromAccount } from "../../common/storage/accountStore";
import { updateAccountBalance } from "../../common/storage/accountBalanceStore";

export default function ApprovePayroll() {
  const [submissions, setSubmissions] = useState([]);
  const [remarks, setRemarks] = useState({});
  const [showPasscodeModal, setShowPasscodeModal] = useState(false);
  const [enteredPasscode, setEnteredPasscode] = useState("");
  const [pendingDecision, setPendingDecision] = useState(null);
  const [message, setMessage] = useState("");

  const APPROVER_PASSCODE = "1234"; // Change to real secure passcode later

  const refresh = () => {
    const all = getAllBatches();
    setSubmissions(all.filter((b) => b.status === "Submitted"));
  };

  useEffect(() => {
    refresh();
  }, []);

  const openPasscodeModal = (batchId, decision) => {
    setPendingDecision({ batchId, decision });
    setShowPasscodeModal(true);
    setEnteredPasscode("");
    setMessage("");
  };

  const confirmDecision = () => {
    if (enteredPasscode === APPROVER_PASSCODE) {
      const { batchId, decision } = pendingDecision;
      const batch = submissions.find(b => b.id === batchId);
  
      if (decision === "Approved") {
        const total = batch.payments.reduce((s, p) => s + Number(p.amount || 0), 0);
        updateAccountBalance(batch.instruction.debitAccount, total, {
          type: "Payroll Payment",
          batchId,
          amount: total,
          status: "Approved"
        });
      }
  
      const meta = {
        approvedBy: "Approver User",
        approvedAt: new Date().toISOString(),
        remarks: remarks[batchId] || "",
      };
      setStatus(batchId, decision, meta);
      refresh();
      setMessage(`Payroll batch ${decision} successfully!`);
      setShowPasscodeModal(false);
    } else {
      setMessage("❌ Incorrect passcode. Try again.");
    }
  };

  const onRemarkChange = (id, value) => {
    setRemarks((prev) => ({ ...prev, [id]: value }));
  };

  const downloadSummary = (batch) => {
    const payments = batch.payments.map((p,i)=>`
      <tr><td>${i+1}</td><td>${p.payeeName}</td><td>${p.accountNumber||p.bankDetails||"-"}</td><td>${p.amount} ${batch.instruction.paymentCurrency}</td></tr>
    `).join("");
  
    openPrintWindow({
      title:`Payroll_${batch.id}_Summary`,
      html: `
        <div class="brand-head">
          <img src="./assets/sc-logo.png" />
          <div>
            <div class="brand-title">Standard Chartered — Payroll Batch Summary</div>
            <div class="muted">Batch: ${batch.id} &nbsp; | &nbsp; Status: ${batch.status}</div>
          </div>
        </div>
        <div><b>Debit Account:</b> ${batch.instruction.debitAccount} &nbsp; | &nbsp; <b>Currency:</b> ${batch.instruction.paymentCurrency} &nbsp; | &nbsp; <b>Date:</b> ${batch.instruction.date}</div>
        <div class="section">
          <table class="table table-sm">
            <thead><tr><th>#</th><th>Payee</th><th>Account/Bank</th><th>Amount</th></tr></thead>
            <tbody>${payments}</tbody>
          </table>
        </div>
      `
    });
  };

  const calculateTotalAmount = (batch) => {
    return batch.payments.reduce((sum, p) => sum + Number(p.amount || 0), 0);
  };

  return (
    <div className="container my-4">
      <div className="d-flex justify-content-between align-items-center mb-3">
        <h2>Approve Payroll</h2>
        
      </div>

      {message && <div className="alert alert-info">{message}</div>}

      {submissions.length === 0 ? (
        <p>No payrolls awaiting approval.</p>
      ) : (
        <div className="table-responsive">
          <table className="table table-bordered align-middle text-center">
            <thead className="table-light">
              <tr>
                <th>Batch ID</th>
                <th>Created</th>
                <th>Payments</th>
                <th>Total Amount</th>
                <th>Remarks</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
              {submissions.map((b) => (
                <tr key={b.id}>
                  <td>{b.id}</td>
                  <td>{b.createdAt ? new Date(b.createdAt).toLocaleString() : "-"}</td>
                  <td>{b.payments.length}</td>
                  <td>
                    {calculateTotalAmount(b)} {b.instruction.paymentCurrency}
                  </td>
                  <td style={{ minWidth: 220 }}>
                    <input
                      type="text"
                      className="form-control form-control-sm"
                      placeholder="Optional remarks"
                      value={remarks[b.id] || ""}
                      onChange={(e) => onRemarkChange(b.id, e.target.value)}
                    />
                  </td>
                  <td className="text-nowrap">
                    <button
                      className="btn btn-success btn-sm me-2"
                      onClick={() => openPasscodeModal(b.id, "Approved")}
                    >
                      Approve
                    </button>
                    <button
                      className="btn btn-danger btn-sm me-2"
                      onClick={() => openPasscodeModal(b.id, "Rejected")}
                    >
                      Reject
                    </button>
                    <button
                      className="btn btn-outline-primary btn-sm"
                      onClick={() => downloadSummary(b)}
                    >
                      Download Summary
                    </button>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}

      {/* Passcode Modal */}
      {showPasscodeModal && (
        <div className="modal show d-block" tabIndex="-1" role="dialog">
          <div className="modal-dialog modal-dialog-centered" role="document">
            <div className="modal-content">
              <div className="modal-header">
                <h5 className="modal-title">Enter Approver Passcode</h5>
                <button
                  type="button"
                  className="btn-close"
                  onClick={() => setShowPasscodeModal(false)}
                ></button>
              </div>
              <div className="modal-body">
                <input
                  type="password"
                  className="form-control"
                  placeholder="Enter passcode"
                  value={enteredPasscode}
                  onChange={(e) => setEnteredPasscode(e.target.value)}
                />
                {message && <p className="text-danger mt-2">{message}</p>}
              </div>
              <div className="modal-footer">
                <button className="btn btn-secondary" onClick={() => setShowPasscodeModal(false)}>
                  Cancel
                </button>
                <button className="btn btn-primary" onClick={confirmDecision}>
                  Confirm
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}



























Customer.java
public class Customer {
    private int customerId;
    private String name;
    private String email;
    private String contact;
    private String accountType;

    public Customer(int customerId, String name, String email, String contact, String accountType) {
        this.customerId = customerId;
        this.name = name;
        this.email = email;
        this.contact = contact;
        this.accountType = accountType;
    }

    public int getCustomerId() {
        return customerId;
    }

    public String getName() {
        return name;
    }

    public String getEmail() {
        return email;
    }

    public String getContact() {
        return contact;
    }

    public String getAccountType() {
        return accountType;
    }

    @Override
    public String toString() {
        return "Customer Id = " + customerId +
                ", Customer name = " + name +
                ", Customer email = " + email +
                ", Customer contact = " + contact +
                ", Account type = " + accountType;
    }
}

CustomerService.java (Interface)
import java.util.List;

public interface CustomerService {
    void addCustomer(String name, String email, String contact, String accountType);
    List<Customer> getAllCustomers();
    Customer searchCustomer(int customerId);
    boolean deleteCustomer(int customerId);
}

CustomerServiceImpl.java
import java.util.*;

public class CustomerServiceImpl implements CustomerService {
    private List<Customer> customers = new ArrayList<>();
    private Random random = new Random();

    @Override
    public void addCustomer(String name, String email, String contact, String accountType) {
        int customerId = 1000 + random.nextInt(9000); // Auto generate ID
        Customer customer = new Customer(customerId, name, email, contact, accountType);
        customers.add(customer);
        System.out.println("Customer added successfully with customer id " + customerId);
    }

    @Override
    public List<Customer> getAllCustomers() {
        return customers;
    }

    @Override
    public Customer searchCustomer(int customerId) {
        for (Customer c : customers) {
            if (c.getCustomerId() == customerId) {
                return c;
            }
        }
        return null;
    }

    @Override
    public boolean deleteCustomer(int customerId) {
        Iterator<Customer> iterator = customers.iterator();
        while (iterator.hasNext()) {
            Customer c = iterator.next();
            if (c.getCustomerId() == customerId) {
                iterator.remove();
                return true;
            }
        }
        return false;
    }
}

BankApp.java
import java.util.Scanner;

public class BankApp {
    private CustomerService service = new CustomerServiceImpl();
    private Scanner sc = new Scanner(System.in);

    public void start() {
        while (true) {
            System.out.println("\nWelcome to Standard Chartered Bank");
            System.out.println("Please enter your choice");
            System.out.println("1 for Add new Customer");
            System.out.println("2 for Display Customers");
            System.out.println("3 for Search Customer");
            System.out.println("4 for Delete Customer");
            System.out.println("5 for Exit the bank application");

            int choice = sc.nextInt();
            sc.nextLine(); // consume newline

            switch (choice) {
                case 1:
                    addCustomer();
                    break;

                case 2:
                    displayCustomers();
                    break;

                case 3:
                    searchCustomer();
                    break;

                case 4:
                    deleteCustomer();
                    break;

                case 5:
                    System.out.println("Exiting the application. Goodbye!");
                    sc.close();
                    System.exit(0);

                default:
                    System.out.println("Invalid choice. Please try again.");
            }
        }
    }

    private void addCustomer() {
        System.out.print("Enter name: ");
        String name = sc.nextLine();

        System.out.print("Enter email: ");
        String email = sc.nextLine();

        System.out.print("Enter contact: ");
        String contact = sc.nextLine();

        System.out.print("Enter account type (Savings or Current): ");
        String accountType = sc.nextLine();

        service.addCustomer(name, email, contact, accountType);
    }

    private void displayCustomers() {
        System.out.println("---- Customer List ----");
        for (Customer c : service.getAllCustomers()) {
            System.out.println(c);
        }
    }

    private void searchCustomer() {
        System.out.print("Please enter customer id: ");
        int searchId = sc.nextInt();
        Customer found = service.searchCustomer(searchId);
        if (found != null) {
            System.out.println(found);
        } else {
            System.out.println("Customer not found.");
        }
    }

    private void deleteCustomer() {
        System.out.print("Please enter customer id to delete: ");
        int deleteId = sc.nextInt();
        if (service.deleteCustomer(deleteId)) {
            System.out.println("Customer deleted successfully.");
        } else {
            System.out.println("Customer not found.");
        }
    }
}

Main.java
public class Main {
    public static void main(String[] args) {
        BankApp app = new BankApp();
        app.start();
    }
}

import React, { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { getAllBatches, setStatus, deleteBatch, downloadText } from "../../common/storage/payrollStore";
 
export default function ManagePayroll() {
  const [batches, setBatches] = useState([]);
  const [selectedBatch, setSelectedBatch] = useState(null);
  const [currentPage, setCurrentPage] = useState(1);
  const itemsPerPage = 6; // fixed number of records per page
  const navigate = useNavigate();
 
  useEffect(() => {
    setBatches(getAllBatches());
  }, []);
 
  const refresh = () => setBatches(getAllBatches());
 
  const editBatch = (batchId) => navigate("/payroll", { state: { batchId } });
 
  const submitDraft = (batchId) => {
    setStatus(batchId, "Submitted", { updatedAt: new Date().toISOString() });
    refresh();
  };
 
  const remove = (batchId) => {
    deleteBatch(batchId);
    refresh();
  };
 
  const viewDetails = (batch) => setSelectedBatch(batch);
  const closeModal = () => setSelectedBatch(null);
 
  const calculateTotalAmount = (batch) => {
    return batch.payments.reduce((sum, p) => sum + Number(p.amount || 0), 0);
  };
 
  // Pagination logic
  const indexOfLast = currentPage * itemsPerPage;
  const indexOfFirst = indexOfLast - itemsPerPage;
  const currentBatches = batches.slice(indexOfFirst, indexOfLast);
  const totalPages = Math.ceil(batches.length / itemsPerPage);
 
  const goToPage = (page) => {
    if (page > 0 && page <= totalPages) {
      setCurrentPage(page);
    }
  };
 
  return (
    <div className="container-fluid p-0" style={{ marginTop: "0px" }}>
      <div className="card" style={{ marginTop: "0px" }}>
        <div className="card-header text-center p-2">
          <h2 className="mb-0">Manage Payroll</h2>
        </div>
 
        <div className="card-body p-2">
          <table className="table table-bordered text-center align-middle mb-0">
            <thead className="table-light">
              <tr>
                <th>Sl. No</th>
                <th>Batch ID</th>
                <th>Date Created</th>
                <th>Payments Count</th>
                <th>Total Amount</th>
                <th>Status</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
              {currentBatches.length === 0 && (
                <tr>
                  <td colSpan="7">No payroll batches found.</td>
                </tr>
              )}
              {currentBatches.map((b, idx) => (
                <tr key={b.id}>
                  <td>{indexOfFirst + idx + 1}</td>
                  <td>{b.id}</td>
                  <td>{b.createdAt ? new Date(b.createdAt).toLocaleString() : "-"}</td>
                  <td>{b.payments.length}</td>
                  <td>
                    {calculateTotalAmount(b)} {b.instruction.paymentCurrency}
                  </td>
                  <td>
                    <span
                      className={
                        "badge " +
                        (b.status === "Approved"
                          ? "bg-success"
                          : b.status === "Rejected"
                          ? "bg-danger"
                          : b.status === "Submitted"
                          ? "bg-warning text-dark"
                          : "bg-secondary")
                      }
                    >
                      {b.status}
                    </span>
                  </td>
                  <td>
                    <button
                      className="btn btn-sm btn-info me-2"
                      onClick={() => viewDetails(b)}
                    >
                      View
                    </button>
                    {b.status === "Draft" && (
                      <>
                        <button
                          className="btn btn-sm btn-primary me-2"
                          onClick={() => editBatch(b.id)}
                        >
                          Edit
                        </button>
                        <button
                          className="btn btn-sm btn-success me-2"
                          onClick={() => submitDraft(b.id)}
                        >
                          Submit
                        </button>
                        <button
                          className="btn btn-sm btn-outline-danger"
                          onClick={() => remove(b.id)}
                        >
                          Delete
                        </button>
                      </>
                    )}
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
 
          {/* Pagination */}
          {totalPages > 1 && (
            <div className="d-flex justify-content-center mt-2">
              <ul className="pagination pagination-sm mb-0">
                <li className={`page-item ${currentPage === 1 ? "disabled" : ""}`}>
                  <button
                    className="page-link"
                    onClick={() => goToPage(currentPage - 1)}
                  >
                    Previous
                  </button>
                </li>
                {[...Array(totalPages)].map((_, i) => (
                  <li
                    key={i}
                    className={`page-item ${currentPage === i + 1 ? "active" : ""}`}
                  >
                    <button
                      className="page-link"
                      onClick={() => goToPage(i + 1)}
                    >
                      {i + 1}
                    </button>
                  </li>
                ))}
                <li
                  className={`page-item ${
                    currentPage === totalPages ? "disabled" : ""
                  }`}
                >
                  <button
                    className="page-link"
                    onClick={() => goToPage(currentPage + 1)}
                  >
                    Next
                  </button>
                </li>
              </ul>
            </div>
          )}
        </div>
      </div>
 
      {/* Modal for details */}
      {selectedBatch && (
        <div
          className="modal fade show"
          style={{ display: "block", background: "rgba(0,0,0,0.5)" }}
        >
          <div className="modal-dialog modal-lg">
            <div className="modal-content">
              <div className="modal-header">
                <h5 className="modal-title">
                  Batch Details — {selectedBatch.id}
                </h5>
                <button
                  type="button"
                  className="btn-close"
                  onClick={closeModal}
                ></button>
              </div>
              <div className="modal-body">
                <h6>Instruction Details</h6>
                <ul>
                  <li>
                    <strong>Currency:</strong>{" "}
                    {selectedBatch.instruction.paymentCurrency}
                  </li>
                  <li>
                    <strong>Debit Account:</strong>{" "}
                    {selectedBatch.instruction.debitAccount}
                  </li>
                  <li>
                    <strong>Date:</strong> {selectedBatch.instruction.date}
                  </li>
                </ul>
 
                <h6>Payments</h6>
                <table className="table table-sm table-bordered">
                  <thead>
                    <tr>
                      <th>Reference</th>
                      <th>Payee Role</th>
                      <th>Payee Name</th>
                      <th>Account Number</th>
                      <th>Amount</th>
                    </tr>
                  </thead>
                  <tbody>
                    {selectedBatch.payments.map((p, idx) => (
                      <tr key={idx}>
                        <td>{p.reference}</td>
                        <td>{p.payeeDetails}</td>
                        <td>{p.payeeName}</td>
                        <td>{p.accountNumber}</td>
                        <td>
                          {p.amount} {selectedBatch.instruction.paymentCurrency}
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
              <div className="modal-footer">
                <button
                  type="button"
                  className="btn btn-secondary"
                  onClick={closeModal}
                >
                  Close
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}import React, { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { getAllBatches, setStatus, deleteBatch, downloadText } from "../../common/storage/payrollStore";
 
export default function ManagePayroll() {
  const [batches, setBatches] = useState([]);
  const [selectedBatch, setSelectedBatch] = useState(null);
  const [currentPage, setCurrentPage] = useState(1);
  const itemsPerPage = 6; // fixed number of records per page
  const navigate = useNavigate();
 
  useEffect(() => {
    setBatches(getAllBatches());
  }, []);
 
  const refresh = () => setBatches(getAllBatches());
 
  const editBatch = (batchId) => navigate("/payroll", { state: { batchId } });
 
  const submitDraft = (batchId) => {
    setStatus(batchId, "Submitted", { updatedAt: new Date().toISOString() });
    refresh();
  };
 
  const remove = (batchId) => {
    deleteBatch(batchId);
    refresh();
  };
 
  const viewDetails = (batch) => setSelectedBatch(batch);
  const closeModal = () => setSelectedBatch(null);
 
  const calculateTotalAmount = (batch) => {
    return batch.payments.reduce((sum, p) => sum + Number(p.amount || 0), 0);
  };
 
  // Pagination logic
  const indexOfLast = currentPage * itemsPerPage;
  const indexOfFirst = indexOfLast - itemsPerPage;
  const currentBatches = batches.slice(indexOfFirst, indexOfLast);
  const totalPages = Math.ceil(batches.length / itemsPerPage);
 
  const goToPage = (page) => {
    if (page > 0 && page <= totalPages) {
      setCurrentPage(page);
    }
  };
 
  return (
    <div className="container-fluid p-0" style={{ marginTop: "0px" }}>
      <div className="card" style={{ marginTop: "0px" }}>
        <div className="card-header text-center p-2">
          <h2 className="mb-0">Manage Payroll</h2>
        </div>
 
        <div className="card-body p-2">
          <table className="table table-bordered text-center align-middle mb-0">
            <thead className="table-light">
              <tr>
                <th>Sl. No</th>
                <th>Batch ID</th>
                <th>Date Created</th>
                <th>Payments Count</th>
                <th>Total Amount</th>
                <th>Status</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
              {currentBatches.length === 0 && (
                <tr>
                  <td colSpan="7">No payroll batches found.</td>
                </tr>
              )}
              {currentBatches.map((b, idx) => (
                <tr key={b.id}>
                  <td>{indexOfFirst + idx + 1}</td>
                  <td>{b.id}</td>
                  <td>{b.createdAt ? new Date(b.createdAt).toLocaleString() : "-"}</td>
                  <td>{b.payments.length}</td>
                  <td>
                    {calculateTotalAmount(b)} {b.instruction.paymentCurrency}
                  </td>
                  <td>
                    <span
                      className={
                        "badge " +
                        (b.status === "Approved"
                          ? "bg-success"
                          : b.status === "Rejected"
                          ? "bg-danger"
                          : b.status === "Submitted"
                          ? "bg-warning text-dark"
                          : "bg-secondary")
                      }
                    >
                      {b.status}
                    </span>
                  </td>
                  <td>
                    <button
                      className="btn btn-sm btn-info me-2"
                      onClick={() => viewDetails(b)}
                    >
                      View
                    </button>
                    {b.status === "Draft" && (
                      <>
                        <button
                          className="btn btn-sm btn-primary me-2"
                          onClick={() => editBatch(b.id)}
                        >
                          Edit
                        </button>
                        <button
                          className="btn btn-sm btn-success me-2"
                          onClick={() => submitDraft(b.id)}
                        >
                          Submit
                        </button>
                        <button
                          className="btn btn-sm btn-outline-danger"
                          onClick={() => remove(b.id)}
                        >
                          Delete
                        </button>
                      </>
                    )}
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
 
          {/* Pagination */}
          {totalPages > 1 && (
            <div className="d-flex justify-content-center mt-2">
              <ul className="pagination pagination-sm mb-0">
                <li className={`page-item ${currentPage === 1 ? "disabled" : ""}`}>
                  <button
                    className="page-link"
                    onClick={() => goToPage(currentPage - 1)}
                  >
                    Previous
                  </button>
                </li>
                {[...Array(totalPages)].map((_, i) => (
                  <li
                    key={i}
                    className={`page-item ${currentPage === i + 1 ? "active" : ""}`}
                  >
                    <button
                      className="page-link"
                      onClick={() => goToPage(i + 1)}
                    >
                      {i + 1}
                    </button>
                  </li>
                ))}
                <li
                  className={`page-item ${
                    currentPage === totalPages ? "disabled" : ""
                  }`}
                >
                  <button
                    className="page-link"
                    onClick={() => goToPage(currentPage + 1)}
                  >
                    Next
                  </button>
                </li>
              </ul>
            </div>
          )}
        </div>
      </div>
 
      {/* Modal for details */}
      {selectedBatch && (
        <div
          className="modal fade show"
          style={{ display: "block", background: "rgba(0,0,0,0.5)" }}
        >
          <div className="modal-dialog modal-lg">
            <div className="modal-content">
              <div className="modal-header">
                <h5 className="modal-title">
                  Batch Details — {selectedBatch.id}
                </h5>
                <button
                  type="button"
                  className="btn-close"
                  onClick={closeModal}
                ></button>
              </div>
              <div className="modal-body">
                <h6>Instruction Details</h6>
                <ul>
                  <li>
                    <strong>Currency:</strong>{" "}
                    {selectedBatch.instruction.paymentCurrency}
                  </li>
                  <li>
                    <strong>Debit Account:</strong>{" "}
                    {selectedBatch.instruction.debitAccount}
                  </li>
                  <li>
                    <strong>Date:</strong> {selectedBatch.instruction.date}
                  </li>
                </ul>
 
                <h6>Payments</h6>
                <table className="table table-sm table-bordered">
                  <thead>
                    <tr>
                      <th>Reference</th>
                      <th>Payee Role</th>
                      <th>Payee Name</th>
                      <th>Account Number</th>
                      <th>Amount</th>
                    </tr>
                  </thead>
                  <tbody>
                    {selectedBatch.payments.map((p, idx) => (
                      <tr key={idx}>
                        <td>{p.reference}</td>
                        <td>{p.payeeDetails}</td>
                        <td>{p.payeeName}</td>
                        <td>{p.accountNumber}</td>
                        <td>
                          {p.amount} {selectedBatch.instruction.paymentCurrency}
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
              <div className="modal-footer">
                <button
                  type="button"
                  className="btn btn-secondary"
                  onClick={closeModal}
                >
                  Close
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}














import React, { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { getAllBatches, setStatus, deleteBatch } from "../../common/storage/payrollStore";

export default function ManagePayroll() {
  const [batches, setBatches] = useState([]);
  const [selectedBatch, setSelectedBatch] = useState(null);
  const [currentPage, setCurrentPage] = useState(1);
  const itemsPerPage = 6; // fixed number of records per page
  const navigate = useNavigate();

  useEffect(() => {
    setBatches(getAllBatches());
  }, []);

  const refresh = () => setBatches(getAllBatches());

  const editBatch = (batchId) => navigate("/payroll", { state: { batchId } });

  const submitDraft = (batchId) => {
    setStatus(batchId, "Submitted", { updatedAt: new Date().toISOString() });
    refresh();
  };

  const remove = (batchId) => {
    deleteBatch(batchId);
    refresh();
  };

  const viewDetails = (batch) => setSelectedBatch(batch);
  const closeModal = () => setSelectedBatch(null);

  const calculateTotalAmount = (batch) => {
    return batch.payments.reduce((sum, p) => sum + Number(p.amount || 0), 0);
  };

  // Pagination logic
  const indexOfLast = currentPage * itemsPerPage;
  const indexOfFirst = indexOfLast - itemsPerPage;
  const currentBatches = batches.slice(indexOfFirst, indexOfLast);
  const totalPages = Math.ceil(batches.length / itemsPerPage);

  return (
    <div className="container-fluid p-0" style={{ marginTop: "0px" }}>
      <div className="card" style={{ marginTop: "0px" }}>
        <div className="card-header text-center p-2">
          <h2 className="mb-0">Manage Payroll</h2>
        </div>

        <div className="card-body p-2">
          <table className="table table-bordered text-center align-middle mb-0">
            <thead className="table-light">
              <tr>
                <th>Sl. No</th>
                <th>Batch ID</th>
                <th>Date Created</th>
                <th>Payments Count</th>
                <th>Total Amount</th>
                <th>Status</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
              {currentBatches.length === 0 && (
                <tr>
                  <td colSpan="7">No payroll batches found.</td>
                </tr>
              )}
              {currentBatches.map((b, idx) => (
                <tr key={b.id}>
                  <td>{indexOfFirst + idx + 1}</td>
                  <td>{b.id}</td>
                  <td>
                    {b.createdAt ? new Date(b.createdAt).toLocaleString() : "-"}
                  </td>
                  <td>{b.payments.length}</td>
                  <td>
                    {calculateTotalAmount(b)} {b.instruction.paymentCurrency}
                  </td>
                  <td>
                    <span
                      className={
                        "badge " +
                        (b.status === "Approved"
                          ? "bg-success"
                          : b.status === "Rejected"
                          ? "bg-danger"
                          : b.status === "Submitted"
                          ? "bg-warning text-dark"
                          : "bg-secondary")
                      }
                    >
                      {b.status}
                    </span>
                  </td>
                  <td>
                    <button
                      className="btn btn-sm btn-info me-2"
                      onClick={() => viewDetails(b)}
                    >
                      View
                    </button>
                    {b.status === "Draft" && (
                      <>
                        <button
                          className="btn btn-sm btn-primary me-2"
                          onClick={() => editBatch(b.id)}
                        >
                          Edit
                        </button>
                        <button
                          className="btn btn-sm btn-success me-2"
                          onClick={() => submitDraft(b.id)}
                        >
                          Submit
                        </button>
                        <button
                          className="btn btn-sm btn-outline-danger"
                          onClick={() => remove(b.id)}
                        >
                          Delete
                        </button>
                      </>
                    )}
                  </td>
                </tr>
              ))}
            </tbody>
          </table>

          {/* Pagination - same as ApprovePayroll */}
          {totalPages > 0 && (
            <div className="d-flex justify-content-center mt-3">
              <button
                className="btn btn-secondary me-2"
                disabled={currentPage === 1}
                onClick={() => setCurrentPage((p) => p - 1)}
              >
                Prev
              </button>
              <span className="align-self-center">
                Page {currentPage} of {totalPages}
              </span>
              <button
                className="btn btn-secondary ms-2"
                disabled={currentPage === totalPages}
                onClick={() => setCurrentPage((p) => p + 1)}
              >
                Next
              </button>
            </div>
          )}
        </div>
      </div>

      {/* Modal for details */}
      {selectedBatch && (
        <div
          className="modal fade show"
          style={{ display: "block", background: "rgba(0,0,0,0.5)" }}
        >
          <div className="modal-dialog modal-lg">
            <div className="modal-content">
              <div className="modal-header">
                <h5 className="modal-title">
                  Batch Details — {selectedBatch.id}
                </h5>
                <button
                  type="button"
                  className="btn-close"
                  onClick={closeModal}
                ></button>
              </div>
              <div className="modal-body">
                <h6>Instruction Details</h6>
                <ul>
                  <li>
                    <strong>Currency:</strong>{" "}
                    {selectedBatch.instruction.paymentCurrency}
                  </li>
                  <li>
                    <strong>Debit Account:</strong>{" "}
                    {selectedBatch.instruction.debitAccount}
                  </li>
                  <li>
                    <strong>Date:</strong> {selectedBatch.instruction.date}
                  </li>
                </ul>

                <h6>Payments</h6>
                <table className="table table-sm table-bordered">
                  <thead>
                    <tr>
                      <th>Reference</th>
                      <th>Payee Role</th>
                      <th>Payee Name</th>
                      <th>Account Number</th>
                      <th>Amount</th>
                    </tr>
                  </thead>
                  <tbody>
                    {selectedBatch.payments.map((p, idx) => (
                      <tr key={idx}>
                        <td>{p.reference}</td>
                        <td>{p.payeeDetails}</td>
                        <td>{p.payeeName}</td>
                        <td>{p.accountNumber}</td>
                        <td>
                          {p.amount} {selectedBatch.instruction.paymentCurrency}
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
              <div className="modal-footer">
                <button
                  type="button"
                  className="btn btn-secondary"
                  onClick={closeModal}
                >
                  Close
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}










